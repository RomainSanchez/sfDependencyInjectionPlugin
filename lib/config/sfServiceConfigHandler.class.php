<?php

/*
 * This file is part of the sfDependencyInjectionPlugin package.
 * (c) Issei Murasawa <issei.m7@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Dumper\PhpDumper;

/**
 * @author Issei Murasawa <issei.m7@gmail.com>
 *
 * @link https://github.com/symfony/HttpKernel/blob/v2.3.27/Kernel.php
 */
class sfServiceConfigHandler extends sfYamlConfigHandler
{
    /**
     * {@inheritdoc}
     */
    public function execute($configFiles)
    {
        $isSymfonyNewerThan150 = 0 <= version_compare(SYMFONY_VERSION, '1.5.0');

        $class = sfConfig::get('sf_container_class');
        $baseClass = $isSymfonyNewerThan150 ? 'sfContainer' : 'Container';

        $container = $this->buildContainer($configFiles, $isSymfonyNewerThan150);
        $container->compile();

        $content = $this->dumpContainer($container, $class, $baseClass);
        if (!preg_match('{^<\?php(.+?)((?:/\*\*\n.+?\*/\n)?class.+)$}s', $content, $matches)) {
            throw new RuntimeException('Dumped container content is invalid.');
        }

        // compile data
        $returnValue = sprintf(
            "<?php\n" .
            "// auto-generated by sfServiceConfigHandler\n" .
            "// date: %s\n\n" .
            "%s\n\n" .
            "\$class = '%s';\n" .
            "if (!class_exists(\$class, false)) {\n" .
            "%s\n" .
            "}\n" .
            "return \$class;\n\n",
            date('Y/m/d H:i:s'), trim($matches[1]), $class, trim($matches[2])
        );

        return $returnValue;
    }

    private function buildContainer($configFiles, $isSymfonyNewerThan150)
    {
        $container = new ContainerBuilder();
        $container->setResourceTracking(false);

        $loader = new sfContainerArrayLoader($container);
        $loader->load(sfDefineEnvironmentConfigHandler::getConfiguration($configFiles));

        if ($isSymfonyNewerThan150) {
            $container->register('sf_event_dispatcher', 'sfEventDispatcher')->setSynthetic(true);
            $container->register('sf_formatter', 'sfFormatter')->setSynthetic(true);
            $container->register('sf_user', 'sfUser')->setSynthetic(true);
            $container->register('sf_routing', 'sfUser')->setSynthetic(true);
        }

        return $container;
    }

    private function dumpContainer($container, $class, $baseClass)
    {
        $dumper = new PhpDumper($container);
        $content = $dumper->dump(array('class' => $class, 'base_class' => $baseClass));

        if (!sfConfig::get('sf_debug')) {
            $content = self::stripComments($content);
        }

        return $content;
    }

    /**
     * Removes comments from a PHP source string.
     *
     * We don't use the PHP php_strip_whitespace() function
     * as we want the content to be readable and well-formatted.
     *
     * @param string $source A PHP string
     *
     * @return string The PHP string with the comments removed
     *
     * @link https://github.com/symfony/HttpKernel/blob/v2.3.27/Kernel.php#L728
     */
    public static function stripComments($source)
    {
        if (!function_exists('token_get_all')) {
            return $source;
        }

        $rawChunk = '';
        $output = '';
        $tokens = token_get_all($source);
        $ignoreSpace = false;
        for (reset($tokens); false !== $token = current($tokens); next($tokens)) {
            if (is_string($token)) {
                $rawChunk .= $token;
            } elseif (T_START_HEREDOC === $token[0]) {
                $output .= $rawChunk.$token[1];
                do {
                    $token = next($tokens);
                    $output .= $token[1];
                } while ($token[0] !== T_END_HEREDOC);
                $rawChunk = '';
            } elseif (T_WHITESPACE === $token[0]) {
                if ($ignoreSpace) {
                    $ignoreSpace = false;

                    continue;
                }

                // replace multiple new lines with a single newline
                $rawChunk .= preg_replace(array('/\n{2,}/S'), "\n", $token[1]);
            } elseif (in_array($token[0], array(T_COMMENT, T_DOC_COMMENT))) {
                $ignoreSpace = true;
            } else {
                $rawChunk .= $token[1];

                // The PHP-open tag already has a new-line
                if (T_OPEN_TAG === $token[0]) {
                    $ignoreSpace = true;
                }
            }
        }

        $output .= $rawChunk;

        return $output;
    }
}
